import{_ as e,c as a,o as t,V as o}from"./chunks/framework.szqEfhRr.js";const p=JSON.parse('{"title":"Domain","description":"","frontmatter":{},"headers":[],"relativePath":"structure/domain.md","filePath":"structure/domain.md","lastUpdated":null}'),i={name:"structure/domain.md"},r=o('<h1 id="domain" tabindex="-1">Domain <a class="header-anchor" href="#domain" aria-label="Permalink to &quot;Domain&quot;">​</a></h1><p>The Domain or domain model is what makes the project unique. With requirements and terminology of the problem being solved in mind (the problem context), you build an abstraction that consists of entities, their relationships, and logic that operates these entities. To focus on the complex part of the problem, domain is, ideally, separated from infrastructure part of the system (that&#39;s how to save data into a database, how to form HTTP response etc.).</p><div class="tip custom-block"><p class="custom-block-title">Note:</p><p>Such isolation is suitable for complex systems. If your project domain is basically <code>create/read/update/delete</code> for a set of records with not much complex logic, it makes no sense to apply a complex solution to a simple problem. Individual concepts of domain design below could be applied separately so make sure to check these even if your project isn&#39;t that complicated.</p></div><h2 id="bounded-context" tabindex="-1">Bounded context <a class="header-anchor" href="#bounded-context" aria-label="Permalink to &quot;Bounded context&quot;">​</a></h2><p>It&#39;s nearly impossible to build a model that solves multiple problems that isn&#39;t too complicated by itself. Therefore, it&#39;s a good practice to divide the domain into several use-cases and have a separate model for each use-case. Such separated models are called &quot;bounded contexts&quot;.</p><h2 id="building-blocks" tabindex="-1">Building blocks <a class="header-anchor" href="#building-blocks" aria-label="Permalink to &quot;Building blocks&quot;">​</a></h2><p>There are various building blocks that are typically used when describing domain models. It isn&#39;t mandatory to use them all.</p><h3 id="entity" tabindex="-1">Entity <a class="header-anchor" href="#entity" aria-label="Permalink to &quot;Entity&quot;">​</a></h3><p>Entity is a uniquely identifiable object such as user, product, payment etc. When comparing them, you&#39;re checking ID, not the attribute values. If there are two objects with different attributes but the same ID, they&#39;re considered being the same thing.</p><h3 id="value-object" tabindex="-1">Value object <a class="header-anchor" href="#value-object" aria-label="Permalink to &quot;Value object&quot;">​</a></h3><p>Value object describes an object by its characteristics. For example, a price that consists of value and currency. When comparing such objects, you&#39;re checking actual values. If they match, an object is considered being the same.</p><h3 id="aggregate" tabindex="-1">Aggregate <a class="header-anchor" href="#aggregate" aria-label="Permalink to &quot;Aggregate&quot;">​</a></h3><p>Aggregate is a set of domain objects such as entities and value objects and additional data that could be treated as a single unit. It usually represents a compound object from a domain model such as shop order or HR person dossier.</p><p>One of the components of an aggregate is called a root. The root identifies an aggregate as a whole and should be used to access it.</p><h3 id="domain-event" tabindex="-1">Domain event <a class="header-anchor" href="#domain-event" aria-label="Permalink to &quot;Domain event&quot;">​</a></h3><p>An aggregate, while processed, may raise events. For example, when order is confirmed, <code>OrderConfirmed</code> event would be risen so other parts of the system may react on these.</p><h3 id="data-transfer-object" tabindex="-1">Data transfer object <a class="header-anchor" href="#data-transfer-object" aria-label="Permalink to &quot;Data transfer object&quot;">​</a></h3><p>Data transfer object or DTO is an object which only purpose is to hold data as is. It&#39;s commonly used to pass data between different services.</p><h3 id="service" tabindex="-1">Service <a class="header-anchor" href="#service" aria-label="Permalink to &quot;Service&quot;">​</a></h3><p>Service is a class that contains a standalone operation within the context of your domain model. See &quot;<a href="./service.html">service components</a>&quot;.</p><h3 id="repository" tabindex="-1">Repository <a class="header-anchor" href="#repository" aria-label="Permalink to &quot;Repository&quot;">​</a></h3><p>The repository task is to abstract away how domain objects are obtained. These are usually separated in two parts: an interface that stays in the domain layer and implementation that&#39;s situated in infrastructure layer. In such a way, domain doesn&#39;t care how data are obtained and saves and may be focused around the complicated business logic instead.</p><p>Repository is usually implemented as a service.</p><h3 id="instantiating-building-blocks" tabindex="-1">Instantiating building blocks <a class="header-anchor" href="#instantiating-building-blocks" aria-label="Permalink to &quot;Instantiating building blocks&quot;">​</a></h3><p>Entity, value object, aggregate and domain event aren&#39;t services and shouldn&#39;t be instantiated through DI container. Using <code>new</code> is the way to go with these.</p><h2 id="references" tabindex="-1">References <a class="header-anchor" href="#references" aria-label="Permalink to &quot;References&quot;">​</a></h2><ul><li><a href="https://martinfowler.com/bliki/BoundedContext.html" target="_blank" rel="noreferrer">BoundedContext by Martin Fowler</a></li><li><a href="https://martinfowler.com/bliki/ValueObject.html" target="_blank" rel="noreferrer">ValueObject by Martin Fowler</a></li><li><a href="https://martinfowler.com/bliki/DDD_Aggregate.html" target="_blank" rel="noreferrer">Aggregate by Marting Fowler</a></li></ul>',27),n=[r];function s(l,c,d,h,u,m){return t(),a("div",null,n)}const f=e(i,[["render",s]]);export{p as __pageData,f as default};

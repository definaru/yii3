import{_ as s,c as e,o as i,V as a}from"./chunks/framework.szqEfhRr.js";const g=JSON.parse('{"title":"Using Yii with event loop","description":"","frontmatter":{},"headers":[],"relativePath":"tutorial/using-with-event-loop.md","filePath":"tutorial/using-with-event-loop.md","lastUpdated":null}'),n={name:"tutorial/using-with-event-loop.md"},t=a(`<h1 id="using-yii-with-event-loop" tabindex="-1">Using Yii with event loop <a class="header-anchor" href="#using-yii-with-event-loop" aria-label="Permalink to &quot;Using Yii with event loop&quot;">​</a></h1><p>Normal PHP web request execution cycle consists of setting up environment, getting response, processing it to form response and sending response. After response is sent, execution is terminated and its context is lost. So, for the subsequent request the whole sequence is repeated. Such an approach has a big advantage in ease of development since a developer doesn&#39;t have to take much care about memory leaks or properly cleaning up context. On the other side, initializing everything for every request takes time and overall consumes up to 50% of processing resources.</p><p>There is an alternative way of running an application. Event loop. The idea is to initialize everything possible once and then process a number of requests using it. Such an approach is usually called event loop.</p><p>There are multiple tools that could be used to achieve it. Notably, <a href="https://roadrunner.dev/" target="_blank" rel="noreferrer">RoadRunner</a> and <a href="https://www.swoole.co.uk/" target="_blank" rel="noreferrer">Swoole</a>.</p><h2 id="event-loop-implications" tabindex="-1">Event loop implications <a class="header-anchor" href="#event-loop-implications" aria-label="Permalink to &quot;Event loop implications&quot;">​</a></h2><p>Event loop worker basically looks the following:</p><div class="language-php vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">php</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">initializeContext</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ($request </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> getRequest</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   $response </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> process</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">($request);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">   emit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">($response);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>Usually, there are multiple workers processing requests at the same time same as with traditional php-fpm.</p><p>That means that there&#39;s more to consider when developing applications.</p><h3 id="processing-is-blocking" tabindex="-1">Processing is blocking <a class="header-anchor" href="#processing-is-blocking" aria-label="Permalink to &quot;Processing is blocking&quot;">​</a></h3><p>Worker process requests one by one that&#39;s current processing is blocking processing next request. That means that long-running processes, same as in general PHP applications, should be put into a background via using a queue.</p><h3 id="services-and-state" tabindex="-1">Services and state <a class="header-anchor" href="#services-and-state" aria-label="Permalink to &quot;Services and state&quot;">​</a></h3><p>Since context in event loop is shared between all request-responses processed by a single worker, all changes in the state of a service made by previous request may affect current request. Moreover, it can be a security problem if data from one user are available to another user.</p><p>There are two ways dealing with it. First, you can avoid having state by making services stateless. Second, you can clean up services at the end of the request processing. In this case, a state resetter will help you:</p><div class="language-php vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">php</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">initializeContext</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">$resetter </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> $container</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\Yiisoft\\Di\\StateResetter</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::class</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ($request </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> getRequest</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   $response </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> process</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">($request);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">   emit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">($response);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   $resetter</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">reset</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// We should reset the state of such services every request.</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h2 id="integrations" tabindex="-1">Integrations <a class="header-anchor" href="#integrations" aria-label="Permalink to &quot;Integrations&quot;">​</a></h2><ul><li><a href="./using-yii-with-roadrunner.html">RoadRunner</a></li><li><a href="./using-yii-with-swoole.html">Swoole</a></li></ul>`,17),l=[t];function r(p,h,o,k,c,d){return i(),e("div",null,l)}const E=s(n,[["render",r]]);export{g as __pageData,E as default};
